https://heuqqdmbyk.feishu.cn/wiki/MQ95wDTtji6ob6kiRkyc9jamnwg
## SpringBootWeb入门
快速开始
```java
package cn.cherzing;  
  
import org.springframework.web.bind.annotation.RequestMapping;  
import org.springframework.web.bind.annotation.RestController;  
  
/**  
 * @author Cherzing  
 * @date 2026/01/23 0023 17:51  
 * @description HelloController  
 */@RestController//表示当前的类是一个请求处理类  
public class HelloController {  
    @RequestMapping("/hello")//访问的路径  
    public String sayHello(String name){  
        System.out.println("name:"+name);  
        return "Hello " + name + " ~";  
    }  
}
```
## HTTP协议
- 超文本传输协议
### 请求协议
- 请求数据获取
	- 请求行
	- 请求头
		- key:value
	- 请求体
		- 与请求头之间间隔一个空行
- 请求数据获取
```java
package cn.cherzing;  
  
import jakarta.servlet.http.HttpServletRequest;  
import org.springframework.web.bind.annotation.RequestMapping;  
import org.springframework.web.bind.annotation.RestController;  
  
/**  
 * @author Cherzing  
 * @date 2026/01/23 0023 18:20  
 * @description RequestController  
 */@RestController  
public class RequestController {  
    @RequestMapping("/request")  
    public String request(HttpServletRequest request){  
        //1. 获取请求方法  
        String method = request.getMethod();  
        System.out.println(method);  
  
        //2. 获取路径  
        String requestURI = request.getRequestURI();  
        System.out.println(method+"--"+requestURI);  
        StringBuffer requestURL = request.getRequestURL();  
        System.out.println(requestURL);  
  
        //3. 获取请求协议  
        String protocol = request.getProtocol();  
        System.out.println(protocol);  
  
        //4. 获取请求参数  
        String parameterName = request.getParameter("name");  
        System.out.println(parameterName);  
        String parameterAge = request.getParameter("age");  
        System.out.println(parameterAge);  
  
        //5.获取请求头  
        String header = request.getHeader("name");  
        System.out.println(header);  
        return "OK";  
  
    }  
}
```
![[cherzing_2026-01-23_18-29-57.png]]
### 响应协议
- 响应格式
	- 响应行
	- 响应头
	- 响应体
![[cherzing_2026-01-23_18-34-10.png]]
- 响应数据设置
```java
package cn.cherzing;  
  
import jakarta.servlet.http.HttpServletResponse;  
import org.springframework.http.ResponseEntity;  
import org.springframework.web.bind.annotation.RequestMapping;  
import org.springframework.web.bind.annotation.RestController;  
  
import java.io.IOException;  
  
/**  
 * @author Cherzing  
 * @date 2026/01/23 0023 18:35  
 * @description ResponseController  
 */@RestController  
public class ResponseController {  
    /**  
     * 方式一：HttpServletResponse设置响应数据  
     * @param response  
     * @throws IOException  
     */    @RequestMapping("/response")  
    public void response(HttpServletResponse response) throws IOException {  
        //1.设置响应状态码  
        response.setStatus(200);  
        //2.设置响应头  
        response.setHeader("name","age");  
        //3.设置响应体  
        response.getWriter().write("Hello response");  
    }  
    @RequestMapping("/response2")  
    public ResponseEntity<String> response(){  
        return ResponseEntity.status(500)  
                .header("group","JavaWebAi")  
                .body("Hello Response");  
    }  
}
```
## SpringBootWeb案例
`@ResponseBody` 注解的作用
- 将controller方法的返回值直接写入HTTP响应体
- 如果是对象或集合，会先转为json，再响应
- @RestController = @Controller + @ResponseBody
## 分层解耦
### 三层架构
- 控制层Controller
	- 接受前端发送的请求，对请求进行处理，并相应数据
- 逻辑层service
	- 处理业务逻辑
- 数据访问层DAO
	- 负责数据访问的操作，CRUD
![[Pasted image 20260124120545.png]]
### 分层解耦
> 现分层解耦的思路是什么？
> - 将项目中的类交给IOC容器管理（IOC，控制反转）
> - 应用程序运行时需要什么对象，直接依赖容器为其提供（DI，依赖注入）
![[cherzing_2026-01-24_12-34-34.png]]

### IoC&DI
1. 将Dao及Service层的实现类，交给Ioc容器管理
	1. 在实现类加上注解`@Component` 
	2. ![[cherzing_2026-01-24_12-39-14.png]]
2. 为Controller及Service注入运行时所依赖的对象
	1. 在需要的接口上添加注解`@Autowired` 
	2. ![[cherzing_2026-01-24_12-39-44.png]]
### IOC
> 创建控制权由程序自身转移到外部（容器），这种思想称为控制反转。

- **定义**：IoC 是一种设计原则，指将对象的创建、生命周期管理及依赖关系的控制权从应用程序代码**反转**给外部容器（如 Spring 容器）。

- **传统方式**：在没有 IoC 的情况下，对象 A 若依赖对象 B，通常由 A 主动通过 `new B()` 创建 B。

- **IoC 方式**：A 不再负责创建 B，而是由 **Spring 容器在运行时创建** B 并“注入”给 A。控制权从程序代码转移到容器。
#### Bean的声明

| 注解            | 说明              | 位置                                |
| ------------- | --------------- | --------------------------------- |
| `@Component`  | 声明bean的基础注解     | 不属于以下三类时，用此注解                     |
| `@Controller` | @Component的衍生注解 | 标注在控制层类上(Controller)              |
| `@Service`    | @Component的衍生注解 | 标注在业务层类上(Service)                 |
| `@Repository` | @Component的衍生注解 | 标注在数据访问层类(DAO)上（由于与mybatis整合，用的少） |
>- 在Springboot集成web开发中，声明控制器bean只能用@Controller。
>
>- 声明bean的注解要想生效，需要被扫描到，启动类默认扫描当前包及其子包。
### DI
> 为应用程序提供运行时，所依赖的资源，称之为**依赖注入**。
> - 注解：`@Autowired` 
- **定义**：DI 是实现 IoC 的具体手段，指容器在运行时动态地将某个依赖（对象或值）注入到组件中。

- **注入方式**（Spring 支持三种）：
1. 属性注入
```Java
@RestController
public class UserController {

    //方式一: 属性注入
    @Autowired
    private UserService userService;
    
  }
```
- 优点：代码简洁、方便快速开发。
- 缺点：隐藏了类之间的依赖关系、可能会破坏类的封装性。
	- 底层用的是反射进行赋值，不是set方法

2. 构造函数注入
```Java
@RestController
public class UserController {

    //方式二: 构造器注入
    private final UserService userService;
    
    @Autowired //如果当前类中只存在一个构造函数, @Autowired可以省略
    public UserController(UserService userService) {
        this.userService = userService;
    }
    
 }   
```
> @Autowired果当前类中只存在一个构造函数，@Autowired可以省略
- 优点：能清晰地看到类的依赖关系、提高了代码的安全性。
    
- 缺点：代码繁琐、如果构造参数过多，可能会导致构造函数臃肿。
    
- **注意：如果只有一个构造函数，@Autowired注解可以省略。（通常来说，也只有一个构造函数）**

3. Setter注入
```Java
/**
 * 用户信息Controller
 */
@RestController
public class UserController {
    
    //方式三: setter注入
    private UserService userService;
    
    @Autowired
    public void setUserService(UserService userService) {
        this.userService = userService;
    }
    
}    
```
- 优点：保持了类的封装性，依赖关系更清晰。
    
- 缺点：需要额外编写setter方法，增加了代码量。
#### 注意
如果在IOC容器中，存在多个相同类型的bean对象，会出现报错：是因为在Spring的容器中，UserService这个类型的bean存在两个，框架不知道具体要注入哪个bean使用，所以就报错了。

解决上述问题？Spring提供三个注解：
- `@Primary`
- `@Qualifier`
- `@Resource` 
**方案一：使用@Primary注解**
当存在多个相同类型的Bean注入时，加上@Primary注解，来确定默认的实现。
```Java
@Primary
@Service
public class UserServiceImpl implements UserService {
}
```

**方案二：使用@Qualifier注解**
指定当前要注入的bean对象。 在@Qualifier的value属性中，指定注入的bean的名称。 @Qualifier注解不能单独使用，必须配合@Autowired使用。
```Java
@RestController
public class UserController {

    @Qualifier("userServiceImpl")
    @Autowired
    private UserService userService;
```

**方案三：使用@Resource注解**
是按照bean的名称进行注入。通过name属性指定要注入的bean的名称。
```Java
@RestController
public class UserController {
        
    @Resource(name = "userServiceImpl")
    private UserService userService;
```

>[!note] 面试题：@Autowird 与 @Resource的区别
>- @Autowired 是spring框架提供的注解，而@Resource是JDK提供的注解
>- @Autowired 默认是按照类型注入，而@Resource是按照名称注入

