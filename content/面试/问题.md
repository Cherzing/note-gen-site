1. 自我介绍
		您好，我叫曹志，是南京工业大学浦江学院计算机科学与技术专业的大四学生，预计2026年毕业。我来自江苏徐州。
		在校期间，我系统学习了Java核心编程、数据结构与算法、操作系统、计算机网络等课程，并具备扎实的后端开发基础。我了解Spring Boot、MyBatis等主流Java开发框架。
		在项目方面，我作为核心开发人员参与了省级大学生创新创业项目《基于深度卷积神经网络和聚类分析的智能数字化果园系统》，负责后端服务模块的搭建。此外，我还拥有1项软件著作权，并发表过学术论文，具备良好的技术文档撰写与问题解决能力。
		虽然我尚未有企业实习经历，但我在校期间通过课程项目和科研实践积累了较强的工程实现能力和团队协作经验。我英语已通过CET-4，具备良好的技术英文阅读能力。同时，我连续三年获得奖学金，学习自律，抗压能力强。
2. Redis是用来解决什么问题的？
		- **高性能缓存**：作为数据库前面的缓存层，存储热点数据，缓解数据库压力，极大提升应用响应速度。
		- 
3. Redis为什么这么快？
		- **完全基于内存操作**：避免磁盘I/O延迟。
		- **单线程模型（6.0前）**：避免多线程上下文切换和锁竞争；6.0+引入多IO线程，但命令执行仍单线程。
4. redis的内存溢出问题该怎么处理？
		
5. redis的大Key如何识别？怎么处理？
		
6. redis缓存在使用过程中可能会出现的问题？解决方案是什么？
		
7. 深拷贝和浅拷贝的区别
		- **浅拷贝**：只复制对象本身（基本类型复制值，引用类型复制内存地址）。新旧对象的**引用类型成员变量指向同一块内存**。修改其中一个对象的引用成员，会影响另一个。
			- Java中 `Object.clone()` 默认是浅拷贝。
		- **深拷贝**：复制对象本身及其所有引用的对象。新旧对象完全独立，**不共享任何内存地址**。
			- 实现方式：序列化/反序列化、递归调用 `clone()` 方法、手动 new 对象并赋值。
8. 说一下单精度和双精度浮点数的区别
		
9. 浮点数比较的时候，要注意哪些问题？
		**核心问题**：浮点数在计算机中以二进制近似存储，存在**精度损失**，直接使用 `==` 比较可能因极微小误差而失败。
	```java
	// 错误示范
if (0.1 + 0.2 == 0.3) { // 结果为 false!
    // ...
}
	```
10. 说一下大端存储和小端存储
		- **大端模式**：**高位字节**存放在**低地址**，**低位字节**存放在**高地址**。
		- **小端模式**：**高位字节**存放在**高地址**，**低位字节**存放在**低地址**。
11. 除了Java外，还有没有其他熟悉的语言？
		C++
12. Java中的IO流是什么？主要用在哪些方面？分为哪些方式？
		- IO 流是 Java 中处理输入/输出操作的抽象，数据像“水流”一样在程序与数据源（文件、网络、内存等）之间传输。
		- 用途：
			- 文件读写
			- 网络通信
			- 数据交换
		- 方式：
			- 按方向：输入流、输出流
			- 按单位：字节流、字符流
			- 按功能：节点流、处理流
		
13. Java线程的同步控制方法有哪些？
> 	Java控制线程的方法？
		- `synchronized` 关键字（方法/代码块）
14. Java对象的创建方式，除了new外，还有哪些？
		- 反射
		- 克隆
		- 工厂方式
> Java中反射是什么？优点和缺点是什么？
> > Java 引入反射机制（Reflection） 的核心目的是为了在运行时动态获取和操作类的信息，从而增强程序的灵活性、通用性和可扩展性
> > 
		- **是什么**：在**运行时**动态地获取类的信息（如方法、属性、构造器）并操作类或对象的能力。核心 API 在 `java.lang.reflect` 包下。
		- **优点**：
			- **灵活性高**：可以在运行时根据配置或条件动态加载和操作类，实现高度解耦。许多框架（Spring, MyBatis）的核心。
			- **通用代码**：可以编写处理任意类的通用工具（如 JSON 序列化/反序列化库）。
        -  **缺点**：
	        - **性能开销**：反射操作比直接调用慢很多，因为涉及动态解析和方法安全检查。
	        - **代码可读性差**：反射代码通常冗长且不易理解，调试困难。
	        - **安全性问题**：可能被用于执行恶意代码。
 >>反射的三个阶段：
 >>![[cherzing_2026-01-31_10-59-00.png]]
1. 说一下JVM的内存参数
		
2. JVM，讲一下链接验证装配
		
3. 某个接口耗时很长，但其他接口访问正常，该如何排查？
		1. 定位问题接口
		2. 查看监控与日志
		3. 分析可能的问题：
			- 数据库
			- 缓存
			- 外部依赖：接口是否调用了其他慢速的第三方服务或内部微服务？
			- 代码逻辑：是否有复杂计算、死锁
4. 某个接口调用时返回了504异常，该如何排查？
		- 
5. 就是给你一个n，然后输出1-n的所有全排列?
		
6. 反问环节？
		
7. md5加密加盐
		
8. Java优缺点
		
9. 合并两个有序数组
	```java
	package list;  
  
import java.util.Arrays;  
  
/**  
 * @author Cherzing  
 * @date 2026/01/31 0031 11:04  
 * @description TestList  
 */public class TestList {  
  
    public static void main(String[] args) {  
        int[] arr1 = {1, 3, 5, 9};  
        int[] arr2 = {2, 6, 7, 10};  
//        merge1(arr1, arr2);  
        merge2(arr1, arr2);  
    }  
  
    public static void merge1(int[] arr1, int[] arr2) {  
        int length1 = arr1.length;  
        int length2 = arr2.length;  
        int arr[] = Arrays.copyOf(arr1, length1 + length2);  
        for (int i = length1; i < length2 + length1; i++) {  
            arr[i] = arr2[i - length1];  
        }  
        Arrays.sort(arr);  
        for (int i = 0; i < length1 + length2; i++) {  
            System.out.println(arr[i]);  
        }  
    }  
  
    public static void merge2(int[] arr1, int[] arr2) {  
        int len1 = arr1.length;  
        int len2 = arr2.length;  
        int arr[] = new int[len1 + len2];  
  
        int i = 0, j = 0, k = 0;  
        while (i < len1 && j < len2) {  
            if (arr1[i] <= arr2[j]) {  
                arr[k] = arr1[i];  
                i++;  
            } else {  
                arr[k] = arr2[j];  
                j++;  
            }  
            k++;  
        }  
  
        //拷贝剩余元素  
        while (i < len1) {  
            arr[k] = arr1[i];  
            k++;  
            i++;  
        }  
        while (j < len2) {  
            arr[k] = arr2[j];  
            k++;  
            j++;  
        }  
        for (int l = 0; l < len1 + len2; l++) {  
            System.out.println(arr[l]);  
        }  
    }  
}
	```
10. MySQL事务
	- 事务是数据库操作的**一个逻辑单元**，包含一组SQL语句，要么全部成功，要么全部失败。
11. MySQL索引类型
		- Hash索引：不支持范围，适用于精确等值查询
		- B+Tree索引：适合范围查询、排序
12. 介绍递归？
		- 调用自身
13. 递归的终止条件
		- 必须存在**至少一个不调用自身的分支**，否则栈溢出（StackOverflowError）。
14. 递归的优缺点
		**优点**：
			- 代码简洁，逻辑清晰（尤其树/图问题）
			- 符合数学归纳思维
		**缺点**：
			- 函数调用开销大（压栈/弹栈）
			- 可能栈溢出（深度过大）
			- 重复计算（如斐波那契，需记忆化优化）
15. Java继承、特点
		
16. 破解验证码的思路
		

数据库范式：
> > 第一范式
> > 表中的每一列都是**不可再分**的原子值，即每一列都是单一值，不能是数组、集合或记录等非原子结构。
> 
> >第二范式：
> >不存在非主键列对主键的“部分函数依赖”
> >>部分函数依赖：对于组合主键 (A, B) → C，如果只知道A或B之一就能确定C，则C部分依赖于主键